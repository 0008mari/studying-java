# Chapter 8 패키지와 클래스 패스

## 08-1 클래스 패스

클래스 패스 = 자바 가상머신이 클래스 파일을 찾는 경로. 프로그래머가 지정한다.

### 현재 디렉토리를 기준으로 한 실행

cmd창 (명령 프롬프트)에서 자바 프로그램을 컴파일, 실행 하는 경우에 대해, 클래스 패스의 디폴트는 현재 디렉토리이다.

### 클래스 패스의 지정

```
c:\PackageStudy>set classpath
```

현재 설정된 클래스 패스 확인. 없으면 없다고 나옴

set classpath=(경로)

이렇게 해주면 된다.

클래스 패스에는 둘 이상의 경로를 지정할 수 있다. 세미콜론으로 구분하며, 현재 디렉토리는 .으로 표시한다.

### 절대경로 상대경로

생략

### 클래스 패스를 고정시키는 방법

위에서 환경변수 설정하는 방법은 cmd 껐다키면 초기화됨

윈도우에서 환경변수 추가할 수 있지만 이 방법은 피한다 

## 08-2 패키지의 이해

### 패키지 선언의 의미와 목적

클래스가 너무 많아요 너무. 자바8기준 기본제공 클래스만 수천개. 이런 클래스를 상위개념인 패키지를 도입하여 분류한다. 기능을 알기 쉽다. 클래스의 이름이 충돌하는 문제도 막을 수 있다. 패키지 이름을 기업 고유정보 (URL)등으로 설정하면 된다 .

### 이름 충돌이 발생하는 두 클래스의 등장: 상황을 가상으로 구성

* 하나의 소스파일에는 public으로 선언된 클래스의 정의를 하나만 둘 수 있다.
* 소스파일의 이름은 public으로 선언된 클래스의 이름과 동일해야 한다.

### 이름 충돌의 해결을 위한 패키지의 효과

패키지의 선언은 다음과 같은 두 가지 특성을 만들어낸다.

* 클래스 접근 방법의 구분
  * 서로 다른 패키지의 두 클래스는 인스턴스 생성 시 사용하는 이름이 다르다.
* 클래스의 공간적인 구분
  * 서로 다른 패키지의 두 클래스 파일은 저장되는 위치가 다르다.

#### 패키지 이름의 규칙 

* 클래스의 이름과 구분이 되도록, 패키지의 이름은 모두 소문자로 구성
* 인터넷 도메인 이름의 역순으로 패키지 이름을 구성
* 패키지 이름의 끝에 클래스를 정의한 주체 또는 팀을 구분하는 이름을 추가한다.

도메인이 wxfx.com 이고 smart 팀이라고 한다면 패키지 이름은 ``com.wxfx.smart``이다.



패키지 이름이 결정되면 클래스의 인스턴스 생성 방법은 다음과 같이 달라진다.

```java
com.wxfx.smart.Circle c1 = new com.wxfx.smart.Circle(3.5);
com.fxmx.simple.Circle c2 = new com.fxmx.simple.Circle(5.5);
```



클래스 파일이 저장되는 위치도 달라진다.



### 패키지의 선언 및 컴파일 방법

클래스를 패키지로 묶을 때에는, 해당 클래스를 담고 있는 소스파일의 상단에 패키지 선언을 한다.

``package com.wxfx.smart; //패키지 선언``

패키지 파일 컴파일 시 -d 옵션 추가. 

물리적으로 구분되면서 인스턴스의 생성 방법도 구분됨

### 패키지로 묶은 클래스의 접근

패키지 이름과 디렉토리 경로가 일치하기때문에 컴파일러가 찾아서 한다... \

### import 선언

패키지 이름을 늘 붙이고 다니기에 번거롭다.

동일한 이름의 클래스가 중복으로 사용되지 않는 상황에 있어서, 패키지 이름을 생략할 수 있다.

``import com.wxfx.smart.Circle;``

해당 문장은 컴파일러에게 이러한 내용을 전달한다. '앞으로 나오는 Circle은 com.wxfx.smart.Circle을 의미한다!! 알고있으렴'

이렇게 하면

``Circle c1= new Circle(3.5);``

이렇게 사용이 가능하다.

그럼 ?? import를 중복선언하면 어떻게되나요?? '이름 충돌' 발생.

``import com.wxfx.smart.*;``

패키지 자체를 import 선언 가능. 그런데 이런 패키지 대상 import 선언은 이름 충돌이 발생할 수 있고, 또 의도하지 않은 클래스의 인스턴스를 생성할 수 있다. 그러므로 가급적 사용을 자제한다. 