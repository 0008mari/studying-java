# Chapter 16 클래스의 상속 3: 상속의 목적

## 16-1 상속이 도움이 되는 상황의 소개

상속을 하는 이유 '연관된 일련의 클래스들에 대해 공통적인 규약을 정의할 수 있다' 이 문장이 의미하는 바를 이해한다.

### 단순한 인맥 관리 프로그램 

주변 사람 정보 관리가 목적! 저장, 관리할 대상은 아래와 같이 두 부류

대학 동창 (이름, 전공, 전화번호) / 직장 동료 (이름, 부서 전화번호)

그래서 각각 클래스를 짰다!

-> 클래스 따라서 배열도 두개, 저장도 출력도 두번씩 해야함.

너무복잡해진다!

### 인맥 관리 프로그램의 문제를 상속으로 해결하자.

공통되는걸 Friend 클래스로 정의 

다른 부분을 상속받아서 각각 추가.

저장은 생성자. 출력은 따로 함수 만듦.

main에서 호출 한 번에.

저장하는 배열도 한가지. (상위 클래스 타입의 배열을 생성)

## 16-2 Object 클래스와 final 선언 그리고 @Override

앞서, System.out.println의 인자가 모든 인스턴스가 될 수 있음을 확인하였다. 이렇게 인스턴스가 인자로 전달되면, toString 메소드가 호출되면서, 이때 반환되는 문자열이 출력된다. 이렇게 동작하는 이유를 설명하겠다!

### 모든 클래스는 Object 클래스를 상속합니다.

클래스를 정의할 때, 어떤 클래스도 상속하지 않으면 해당 클래스는 java.lang 패키지에 묶여 있는 Object 클래스를 상속하게 된다.

class MyClass {...}

이것과 같아진다 class Myclass extends Object {...}

어차피 클래스의 상위의 상위로 가면 어떤 클래스도 상속하지 않는 클래스가 나타나므로, 모든 클래스는 결국에 Object 클래스를 상속한다고 할 수 있다. (직 간접적으로)

이는 자바의 모든 인스턴스에 공통된 기준 및 규약을 적용하기 위함이다.

한 예시로 자바의 모든 인스턴스는 다음 메소드의 인자로 전달될 수 있다.

public void println (Object x)

// 이것이 System.out.println 메소드이다.

위 메소드의 매개변수 형이 Object 이다. 따라서 자바의 모든 인스턴스는 위 메소드의 인자가 될 수 있다.

또다른예시 - toString 메소드. Object 클래스에 정의되어 있는 메소드인데, 자바에서는 이를 각 클래스에 맞게 가급적 오버라이딩 하라고 조언하고 있다.

### 클래스와 메소드의 final 선언

-클래스를 정의하는 데 있어, 이 클래스를 다른 클래스가 상속하는 것을 원치 않는 경우.

public **final** class MyLastCLS {...}

// MyLastCLS는 다른 클래스가 상속할 수 없음.

대표적인 final 클래스로 String 클래스가 있다. 

-또한 다음과 같이, 메소드 오버라이딩을 허용하지 않을 수 있다.

```java
class Simple {
    // 아래의 메소드는 다른 클래스에서 오버라이딩 하지 않음.
    public final void func(int n) {...}
}
```

### @Override

자바 5에서 도입된 **어노테이션** (이후 별도로 설명 예정)

메소드 오버라이딩과 관련된 부분을 우선 살펴본다.

(예제)

위의 예제는 오버라이딩을 의도했으나, 프로그래머의 실수로 오버라이딩이 안 된 경우이다. (매개변수 타입이 달랐음.)

이런 실수는 흔하지만 발견하기 쉽지 않다. 컴파일 과정에서 실수를 잡아내면 좋겠지만, 문법적 오류가 당연 아니다.

이런 상황을 방지하기 위해 어노테이션 이라는 것을 사용할 수 있다. 어노테이션은 일종의 메모. **자바 컴파일러에게 메시지를 전달하는 것이 목적.**

이렇게 고쳐보자

```java
class ChildAdder extends ParentAdder {
    @Override
    public double add(double a, double b) {
        System.out.println("덧셈을 진행합니다.");
        return a + b;
    }
}
```

이렇게 하면 컴파일러가 컴파일 시 오버라이딩이 되었는지 확인한다. 프로그래머의 의도대로 오버라이딩이 되지 않았다면 다음과 같은 메시지를 컴파일 단계에서 전달해준다.

error: method does not override or implement a method from a supertype

이렇듯 어노테이션 @Override 을 사용하여 오류의 발생을 차단하는 것이 좋다.

